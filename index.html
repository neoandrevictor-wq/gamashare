<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anarchy P2P - Rede Mesh Descentralizada</title>
    <style>
        :root {
            --bg-color: #121212;
            --panel-bg: #1e1e1e;
            --border-color: #333;
            --primary: #bb86fc;
            --danger: #cf6679;
            --text: #e0e0e0;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Modals */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); backdrop-filter: blur(5px);
            display: flex; justify-content: center; align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background: var(--panel-bg); padding: 30px; border-radius: 8px;
            border: 1px solid var(--border-color); width: 90%; max-width: 500px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        .modal-content h2 { margin-bottom: 15px; color: var(--primary); }
        .modal-content p { margin-bottom: 15px; font-size: 0.9em; line-height: 1.5; color: #aaa;}
        input[type="text"] {
            width: 100%; padding: 10px; margin-bottom: 15px;
            background: #000; border: 1px solid var(--border-color); color: white;
            border-radius: 4px; outline: none;
        }
        button {
            background: var(--primary); color: #000; border: none; padding: 10px 20px;
            cursor: pointer; border-radius: 4px; font-weight: bold; width: 100%;
            margin-bottom: 10px; transition: 0.2s;
        }
        button:hover { opacity: 0.8; }
        button.danger { background: var(--danger); }

        /* App Layout */
        #app { display: none; flex: 1; display: flex; flex-direction: column; height: 100%; }
        header {
            padding: 10px 20px; background: var(--panel-bg); border-bottom: 1px solid var(--border-color);
            display: flex; justify-content: space-between; align-items: center;
        }
        .room-info { font-size: 0.9em; color: #aaa; cursor: pointer; }
        
        main { display: flex; flex: 1; overflow: hidden; }
        
        /* Video Grid */
        #video-container {
            flex: 1; padding: 10px; display: grid; gap: 10px;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            grid-auto-rows: minmax(150px, 1fr);
            overflow-y: auto; align-content: start;
        }
        .video-card {
            position: relative; background: #000; border-radius: 8px; overflow: hidden;
            border: 1px solid var(--border-color); aspect-ratio: 16/9; display: flex;
        }
        video { width: 100%; height: 100%; object-fit: cover; }
        .peer-name {
            position: absolute; bottom: 10px; left: 10px; background: rgba(0,0,0,0.6);
            padding: 4px 8px; border-radius: 4px; font-size: 0.8em;
        }
        .peer-controls {
            position: absolute; top: 10px; right: 10px; display: flex; gap: 5px;
            opacity: 0; transition: opacity 0.3s;
        }
        .video-card:hover .peer-controls { opacity: 1; }
        .peer-controls button { padding: 4px; width: auto; font-size: 0.7em; margin: 0; }
        .peer-controls input[type="range"] { width: 60px; }

        /* Sidebar (Chat & Files) */
        #sidebar {
            width: 300px; background: var(--panel-bg); border-left: 1px solid var(--border-color);
            display: flex; flex-direction: column;
        }
        #chat-history {
            flex: 1; overflow-y: auto; padding: 15px; display: flex; flex-direction: column; gap: 10px;
        }
        .message { font-size: 0.85em; background: #2a2a2a; padding: 8px; border-radius: 6px; word-break: break-word;}
        .message strong { color: var(--primary); }
        .message img { max-width: 100%; margin-top: 5px; border-radius: 4px; }
        .system-msg { color: #888; font-style: italic; font-size: 0.8em; text-align: center; }
        
        #controls-panel { padding: 15px; border-top: 1px solid var(--border-color); }
        #controls-panel div { display: flex; gap: 5px; margin-bottom: 10px;}
        #chat-input { margin-bottom: 0; flex: 1; }
        
        @media (max-width: 768px) {
            main { flex-direction: column; }
            #sidebar { width: 100%; height: 300px; border-left: none; border-top: 1px solid var(--border-color); }
        }
    </style>
</head>
<body>

    <!-- Modal de Termos (Prote√ß√£o Jur√≠dica) -->
    <div id="terms-modal" class="modal-overlay">
        <div class="modal-content">
            <h2>‚ö†Ô∏è Termos de Utiliza√ß√£o (Sistema Experimental)</h2>
            <p>Este √© um experimento cient√≠fico e educacional de rede P2P distribu√≠da. <strong>Nenhum servidor central de m√≠dia ou armazenamento √© utilizado.</strong> Todo o tr√°fego ocorre diretamente entre os navegadores dos participantes.</p>
            <p>Ao prosseguir, voc√™ concorda que:</p>
            <ul style="margin-left: 20px; font-size: 0.85em; color: #aaa; margin-bottom: 15px;">
                <li>O autor do software n√£o tem acesso, controle ou responsabilidade sobre o conte√∫do transmitido.</li>
                <li>Qualquer m√≠dia, arquivo ou texto trafega sob criptografia nativa do WebRTC diretamente entre os n√≥s.</li>
                <li>O funcionamento pleno pode causar degrada√ß√£o t√©cnica visual proposital para estabilizar a rede.</li>
            </ul>
            <button onclick="acceptTerms()">Aceito e Compreendo</button>
        </div>
    </div>

    <!-- Modal de Entrada -->
    <div id="join-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h2>Entrar na Malha P2P</h2>
            <input type="text" id="nickname" placeholder="Seu Apelido" required>
            <input type="text" id="room-id" placeholder="ID da Sala (UUID)" required>
            <button onclick="joinRoom()">Conectar</button>
            <button class="danger" onclick="generateRoom()">Criar Nova Sala Segura</button>
        </div>
    </div>

    <!-- Interface Principal -->
    <div id="app" style="display: none;">
        <header>
            <div>
                <strong>Anarchy P2P Mesh</strong> | 
                <span class="room-info" id="room-display" onclick="copyLink()"></span>
            </div>
            <div>
                <button class="danger" style="width: auto; padding: 5px 15px; margin: 0;" onclick="location.reload()">Desconectar</button>
            </div>
        </header>

        <main>
            <div id="video-container">
                <!-- V√≠deo Local -->
                <div class="video-card" id="card-local">
                    <video id="local-video" autoplay muted playsinline></video>
                    <div class="peer-name">Voc√™ (<span id="local-nick-display"></span>)</div>
                </div>
            </div>

            <div id="sidebar">
                <div id="chat-history"></div>
                <div id="controls-panel">
                    <div>
                        <button onclick="toggleMic()" id="btn-mic">üéôÔ∏è Mutar</button>
                        <button onclick="toggleCam()" id="btn-cam">üìπ Esconder</button>
                        <button onclick="shareScreen()" id="btn-screen">üñ•Ô∏è Tela</button>
                    </div>
                    <div>
                        <input type="text" id="chat-input" placeholder="Mensagem... (Cole imagens aqui)">
                        <button style="width: auto; margin:0;" onclick="sendText()">Enviar</button>
                    </div>
                    <div style="margin-top: 5px;">
                        <input type="file" id="file-input" style="display:none" onchange="sendFile(this)">
                        <button onclick="document.getElementById('file-input').click()" style="background:#333; color:white;">üìÅ Enviar Arquivo</button>
                    </div>
                </div>
            </div>
        </main>
    </div>

<script>
    // --- ESTADO GLOBAL ---
    const myId = generateUUID();
    let myNickname = "An√¥nimo";
    let roomId = "";
    let localStream = null;
    let screenStream = null;
    
    // peers[peerId] = { connection, dataChannel, lastHeartbeat }
    const peers = {}; 
    const CHUNK_SIZE = 16384; // 16KB para envio de arquivos via DataChannel

    // Configura√ß√£o WebRTC (Servidores P√∫blicos Livres)
    const webrtcConfig = {
        iceServers: [
            { urls: "stun:stun.l.google.com:19302" },
            { urls: "stun:stun1.l.google.com:19302" }
        ]
    };

    // --- SINALIZA√á√ÉO MOCK (Servidor P√∫blico WebSocket) ---
    // Usamos um relay de teste p√∫blico para o "bootstrap" da conex√£o P2P.
    // Em produ√ß√£o real sem servidor, seria necess√°rio enviar os SDPs manualmente.
    const SIGNALING_SERVER = "wss://echo.websocket.events"; // Relay de echo p√∫blico
    let ws = null;

    // --- INICIALIZA√á√ÉO E UI ---
    function generateUUID() {
        return crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(36).substring(2) + Date.now().toString(36);
    }

    function acceptTerms() {
        document.getElementById('terms-modal').style.display = 'none';
        document.getElementById('join-modal').style.display = 'flex';
        
        const urlParams = new URLSearchParams(window.location.search);
        if(urlParams.has('sala')) {
            document.getElementById('room-id').value = urlParams.get('sala');
        }
    }

    function generateRoom() {
        document.getElementById('room-id').value = generateUUID();
    }

    function copyLink() {
        const url = window.location.origin + window.location.pathname + "?sala=" + roomId;
        navigator.clipboard.writeText(url);
        alert("Link da sala copiado! Compartilhe com os peers.");
    }

    async function joinRoom() {
        myNickname = document.getElementById('nickname').value || "An√¥nimo";
        roomId = document.getElementById('room-id').value;
        if(!roomId) return alert("Insira um UUID de sala v√°lido.");

        document.getElementById('join-modal').style.display = 'none';
        document.getElementById('app').style.display = 'flex';
        
        document.getElementById('room-display').innerText = `Sala: ${roomId} (Clique p/ copiar link)`;
        document.getElementById('local-nick-display').innerText = myNickname;
        window.history.pushState({}, '', `?sala=${roomId}`);

        await setupMedia();
        connectSignaling();
        
        // Loop de degrada√ß√£o adaptativa e self-healing
        setInterval(checkNetworkHealth, 5000);
        setInterval(sendHeartbeat, 3000);
    }

    // --- M√çDIA E DEGRADA√á√ÉO PROGRESSIVA ---
    async function setupMedia() {
        try {
            localStream = await navigator.mediaDevices.getUserMedia({ 
                video: { width: 640, height: 480, frameRate: 24 }, 
                audio: true 
            });
            document.getElementById('local-video').srcObject = localStream;
        } catch (e) {
            console.error("Erro na m√≠dia:", e);
            alert("N√£o foi poss√≠vel acessar a c√¢mera/mic. Funcionando apenas via DataChannel.");
            localStream = new MediaStream(); // Stream vazia para n√£o quebrar RTCPeerConnection
        }
    }

    async function adaptQuality() {
        if(!localStream) return;
        const videoTrack = localStream.getVideoTracks()[0];
        if(!videoTrack) return;

        const peerCount = Object.keys(peers).length;
        try {
            if (peerCount > 8) {
                // Modo Degrada√ß√£o Severa
                await videoTrack.applyConstraints({ width: 160, height: 120, frameRate: 10 });
                addSystemMsg("Qualidade reduzida (Modo Mosaico) devido √† alta densidade de rede.");
            } else if (peerCount > 4) {
                // Modo Degrada√ß√£o Leve
                await videoTrack.applyConstraints({ width: 320, height: 240, frameRate: 15 });
            } else {
                // Modo Padr√£o
                await videoTrack.applyConstraints({ width: 640, height: 480, frameRate: 24 });
            }
        } catch(e) { console.log("Limita√ß√£o do navegador ao aplicar degrada√ß√£o."); }
    }

    // --- SINALIZA√á√ÉO (BOOTSTRAP P2P) ---
    function connectSignaling() {
        ws = new WebSocket(SIGNALING_SERVER);
        
        ws.onopen = () => {
            addSystemMsg("Conectado ao relay global de bootstrap. Buscando peers...");
            // Anuncia entrada na sala
            ws.send(JSON.stringify({ type: 'join', room: roomId, sender: myId }));
        };

        ws.onmessage = async (event) => {
            try {
                const msg = JSON.parse(event.data);
                // Filtra mensagens da pr√≥pria sala e ignora as pr√≥prias
                if (msg.room !== roomId || msg.sender === myId) return;

                if (msg.type === 'join') {
                    // Novo peer entrou. Eu (que j√° estava aqui) crio a Oferta SDP.
                    console.log("Novo peer detectado, iniciando conex√£o:", msg.sender);
                    createPeerConnection(msg.sender, true);
                } 
                else if (msg.type === 'offer') {
                    console.log("Oferta recebida de:", msg.sender);
                    const pc = createPeerConnection(msg.sender, false);
                    await pc.setRemoteDescription(new RTCSessionDescription(msg.sdp));
                    const answer = await pc.createAnswer();
                    await pc.setLocalDescription(answer);
                    ws.send(JSON.stringify({ type: 'answer', room: roomId, sender: myId, target: msg.sender, sdp: answer }));
                } 
                else if (msg.type === 'answer' && msg.target === myId) {
                    console.log("Resposta recebida de:", msg.sender);
                    const pc = peers[msg.sender].connection;
                    await pc.setRemoteDescription(new RTCSessionDescription(msg.sdp));
                } 
                else if (msg.type === 'ice-candidate' && msg.target === myId) {
                    const pc = peers[msg.sender]?.connection;
                    if (pc) await pc.addIceCandidate(new RTCIceCandidate(msg.candidate));
                }
            } catch (e) {
                // Ignora mensagens de outras aplica√ß√µes no echo server p√∫blico
            }
        };
    }

    // --- L√ìGICA WEBRTC MESH ---
    function createPeerConnection(peerId, isInitiator) {
        if (peers[peerId]) return peers[peerId].connection;

        const pc = new RTCPeerConnection(webrtcConfig);
        peers[peerId] = { connection: pc, dataChannel: null, lastHeartbeat: Date.now() };

        // Adiciona m√≠dia local √† conex√£o
        localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

        // ICE Candidates gerados localmente s√£o enviados via WebSocket
        pc.onicecandidate = (event) => {
            if (event.candidate) {
                ws.send(JSON.stringify({ type: 'ice-candidate', room: roomId, sender: myId, target: peerId, candidate: event.candidate }));
            }
        };

        // Recebendo v√≠deo do peer
        pc.ontrack = (event) => {
            if (!document.getElementById(`video-${peerId}`)) {
                createVideoCard(peerId);
            }
            document.getElementById(`video-${peerId}`).srcObject = event.streams[0];
            adaptQuality(); // Ajusta qualidade devido a novo participante
        };

        // Data Channels (Texto, Controle e Arquivos)
        if (isInitiator) {
            const dc = pc.createDataChannel('anarchy-data');
            setupDataChannel(dc, peerId);
        } else {
            pc.ondatachannel = (event) => setupDataChannel(event.channel, peerId);
        }

        // Se for o iniciador, cria a Oferta SDP
        if (isInitiator) {
            pc.createOffer().then(offer => {
                pc.setLocalDescription(offer);
                ws.send(JSON.stringify({ type: 'offer', room: roomId, sender: myId, target: peerId, sdp: offer }));
            });
        }

        return pc;
    }

    function removePeer(peerId) {
        if (peers[peerId]) {
            peers[peerId].connection.close();
            delete peers[peerId];
        }
        const card = document.getElementById(`card-${peerId}`);
        if (card) card.remove();
        addSystemMsg(`Um peer saiu ou perdeu conex√£o.`);
        adaptQuality();
    }

    // --- DATA CHANNELS (O CORA√á√ÉO DO SISTEMA) ---
    function setupDataChannel(dc, peerId) {
        peers[peerId].dataChannel = dc;
        dc.binaryType = 'arraybuffer';

        let incomingFileInfo = null;
        let incomingFileData = [];

        dc.onmessage = (event) => {
            peers[peerId].lastHeartbeat = Date.now();

            // Tratamento de Arquivos em ArrayBuffer
            if (event.data instanceof ArrayBuffer) {
                incomingFileData.push(event.data);
                return;
            }

            // Tratamento de Texto JSON
            try {
                const data = JSON.parse(event.data);
                
                if (data.type === 'heartbeat') return; // Apenas atualiza o timestamp acima
                
                if (data.type === 'chat') {
                    appendMessage(data.nickname, data.text);
                } 
                else if (data.type === 'image') {
                    appendImage(data.nickname, data.base64);
                }
                else if (data.type === 'control') {
                    handleAnarchyControl(data);
                }
                else if (data.type === 'file_start') {
                    incomingFileInfo = data;
                    incomingFileData = [];
                }
                else if (data.type === 'file_end') {
                    const blob = new Blob(incomingFileData);
                    appendFileLink(incomingFileInfo.sender, incomingFileInfo.name, blob);
                    incomingFileInfo = null;
                    incomingFileData = [];
                }
            } catch (e) { console.error("Erro parse DataChannel:", e); }
        };
    }

    function broadcastData(messageObj) {
        const msgStr = JSON.stringify(messageObj);
        Object.values(peers).forEach(p => {
            if (p.dataChannel && p.dataChannel.readyState === 'open') {
                p.dataChannel.send(msgStr);
            }
        });
    }

    // --- TOLER√ÇNCIA A FALHAS ---
    function sendHeartbeat() {
        broadcastData({ type: 'heartbeat' });
    }

    function checkNetworkHealth() {
        const now = Date.now();
        for (const peerId in peers) {
            if (now - peers[peerId].lastHeartbeat > 15000) {
                console.warn(`Timeout detectado para ${peerId}. Expurgando n√≥.`);
                removePeer(peerId);
            }
        }
    }

    // --- INTERFACE E CONTROLES AN√ÅRQUICOS ---
    function createVideoCard(peerId) {
        const div = document.createElement('div');
        div.className = 'video-card';
        div.id = `card-${peerId}`;
        
        div.innerHTML = `
            <video id="video-${peerId}" autoplay playsinline></video>
            <div class="peer-name">Peer An√¥nimo</div>
            <div class="peer-controls">
                <input type="range" min="0" max="1" step="0.1" value="1" onchange="document.getElementById('video-${peerId}').volume = this.value" title="Volume Local">
                <button onclick="sendAnarchyCommand('${peerId}', 'mute')" title="For√ßar Mute">üîá</button>
                <button onclick="sendAnarchyCommand('${peerId}', 'hide')" title="For√ßar C√¢mera Off">üö´</button>
            </div>
        `;
        document.getElementById('video-container').appendChild(div);
    }

    function sendAnarchyCommand(targetId, action) {
        // Envia ordem de execu√ß√£o pela rede. O alvo obedece se receber.
        broadcastData({ type: 'control', target: targetId, action: action, senderNick: myNickname });
        addSystemMsg(`Voc√™ emitiu uma ordem global para o peer alvo.`);
    }

    function handleAnarchyControl(data) {
        if (data.target === myId || data.target === 'all') {
            if (data.action === 'mute') {
                const audioTrack = localStream.getAudioTracks()[0];
                if (audioTrack) audioTrack.enabled = false;
                addSystemMsg(`üö® O ditador ${data.senderNick} mutou o seu microfone.`);
            } 
            else if (data.action === 'hide') {
                const videoTrack = localStream.getVideoTracks()[0];
                if (videoTrack) videoTrack.enabled = false;
                addSystemMsg(`üö® O ditador ${data.senderNick} desligou sua c√¢mera.`);
            }
        }
    }

    function toggleMic() {
        const track = localStream.getAudioTracks()[0];
        if(track) {
            track.enabled = !track.enabled;
            document.getElementById('btn-mic').innerText = track.enabled ? "üéôÔ∏è Mutar" : "üéôÔ∏è Desmutar";
        }
    }

    function toggleCam() {
        const track = localStream.getVideoTracks()[0];
        if(track) {
            track.enabled = !track.enabled;
            document.getElementById('btn-cam').innerText = track.enabled ? "üìπ Esconder" : "üìπ Mostrar";
        }
    }

    async function shareScreen() {
        try {
            if(!screenStream) {
                screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true });
                const screenTrack = screenStream.getVideoTracks()[0];
                
                // Substitui a track em todas as conex√µes
                Object.values(peers).forEach(p => {
                    const sender = p.connection.getSenders().find(s => s.track.kind === 'video');
                    if(sender) sender.replaceTrack(screenTrack);
                });
                
                document.getElementById('local-video').srcObject = screenStream;
                document.getElementById('btn-screen').innerText = "üñ•Ô∏è Parar Tela";

                screenTrack.onended = () => stopScreenShare();
            } else {
                stopScreenShare();
            }
        } catch(e) { console.error("Erro no compartilhamento de tela:", e); }
    }

    function stopScreenShare() {
        screenStream.getTracks().forEach(t => t.stop());
        screenStream = null;
        const videoTrack = localStream.getVideoTracks()[0];
        
        Object.values(peers).forEach(p => {
            const sender = p.connection.getSenders().find(s => s.track.kind === 'video');
            if(sender) sender.replaceTrack(videoTrack);
        });
        
        document.getElementById('local-video').srcObject = localStream;
        document.getElementById('btn-screen').innerText = "üñ•Ô∏è Tela";
    }

    // --- CHAT, IMAGENS E ARQUIVOS ---
    function appendMessage(nick, text) {
        const history = document.getElementById('chat-history');
        history.innerHTML += `<div class="message"><strong>${nick}:</strong> ${text}</div>`;
        history.scrollTop = history.scrollHeight;
    }

    function appendImage(nick, base64) {
        const history = document.getElementById('chat-history');
        history.innerHTML += `<div class="message"><strong>${nick} enviou imagem:</strong><br><img src="${base64}"></div>`;
        history.scrollTop = history.scrollHeight;
    }

    function appendFileLink(nick, filename, blob) {
        const url = URL.createObjectURL(blob);
        const history = document.getElementById('chat-history');
        history.innerHTML += `<div class="message"><strong>${nick} enviou arquivo:</strong><br><a href="${url}" download="${filename}" style="color:var(--primary)">üíæ Baixar ${filename}</a></div>`;
        history.scrollTop = history.scrollHeight;
    }

    function addSystemMsg(text) {
        const history = document.getElementById('chat-history');
        history.innerHTML += `<div class="system-msg">${text}</div>`;
        history.scrollTop = history.scrollHeight;
    }

    function sendText() {
        const input = document.getElementById('chat-input');
        const text = input.value.trim();
        if(text) {
            appendMessage("Voc√™", text);
            broadcastData({ type: 'chat', nickname: myNickname, text: text });
            input.value = '';
        }
    }

    // Evento de colar imagem no chat
    document.getElementById('chat-input').addEventListener('paste', function(e) {
        const items = e.clipboardData.items;
        for (let i = 0; i < items.length; i++) {
            if (items[i].type.indexOf('image') !== -1) {
                const blob = items[i].getAsFile();
                const reader = new FileReader();
                reader.onload = (event) => {
                    const base64 = event.target.result;
                    appendImage("Voc√™", base64);
                    broadcastData({ type: 'image', nickname: myNickname, base64: base64 });
                };
                reader.readAsDataURL(blob);
            }
        }
    });

    // Evento de Envio de Arquivo (Chunked via DataChannel)
    async function sendFile(input) {
        const file = input.files[0];
        if(!file) return;

        addSystemMsg(`Enviando arquivo: ${file.name}...`);
        broadcastData({ type: 'file_start', sender: myNickname, name: file.name, size: file.size });

        const buffer = await file.arrayBuffer();
        let offset = 0;

        // Loop de envio de chunks
        while (offset < buffer.byteLength) {
            const chunk = buffer.slice(offset, offset + CHUNK_SIZE);
            Object.values(peers).forEach(p => {
                if (p.dataChannel && p.dataChannel.readyState === 'open') {
                    p.dataChannel.send(chunk);
                }
            });
            offset += CHUNK_SIZE;
            // Pequeno delay para n√£o encher o buffer do WebRTC
            await new Promise(r => setTimeout(r, 10)); 
        }

        broadcastData({ type: 'file_end', sender: myNickname });
        addSystemMsg(`Arquivo enviado com sucesso.`);
        input.value = '';
    }

    // Suporte ao "Enter" no chat
    document.getElementById('chat-input').addEventListener('keypress', function (e) {
        if (e.key === 'Enter') sendText();
    });

</script>
</body>
</html>